## 1. main函数本质

一个程序的入口是main函数，main函数有两种标准写法，这两种区别在于是否需要对main函数进行传参：

```c
int main(void)                     //main函数不传参
int main(int argc, char *argc[])   //main函数传参，函数也可定义为：int main(int argc, char **argv)
```

在阐述这部分之前，先来探讨下linux下main函数执行的本质。我们知道其他函数都是直接或间接被main函数调用，那main函数是被谁调用的呢？这就涉及到进程的概念了，

fork函数
exec函数族

## 2. main函数之不传参

不对main函数传参的话，直接在函数内添加void即可，函数体内执行的结果就与外界传参无任何关联，如果像控制程序执行，必须修改程序代码再重新编译。那函数中的void是什么含义呢？

### 2.1 类型介绍

编程语言分为强类型语言和弱类型语言，C语言就是强类型语言，而脚本语言如makefile或shell都属于弱类型语言，两者很大的区别在于类型的限定。在强类型语言中变量都有自己明确的类型，因为一个变量要对应内存中的一段内存，编译器需要这个类型来确定在内存中占用多大的字节和这段内存的解析方法，如int型变量，在内存中占用4个字节，这4个字节是用int类型去解析。而弱类型语言是没有类型这种明确划分的，所有的变量都是一种类型，一般都是字符串，在使用的时候再去根据需要来处理变量。

值得一提的是，在C语言中，假设同一个变量在内存中分配的首地址都是相同的(0x0000)，不同的类型会决定内存地址的长度不同，int型会占用4个字节，则存储地址为0x0000 ~ 0x0003，char型会占用1个字节，存储地址为0x0000 ~ 0x0001，double型会占用8个字节，存储地址为0x0000 ~ 0x0007。同时，int型和float型占用的字节数相同，都是0x0000 ~ 0x0003的4个字节，但对于这一段内存长度的空间解析方式是不同的，int型空间按int型方式去解析，float型按float型方式去解析，如果用int型方式去解析float型内存空间，解析出来的值很大可能就不正确。

注意：变量有明确的类型，内存空间没有类型划分。这是因为在内存空间中，无论存储着int型还是double型变量，对于内存来说都只是一个数值，而对于变量来说，是需要按int型解析还是double型解析，这是不同的。

### 2.2 void类型

很多教程上将void解释为空，void类型解释为空类型或无类型，其实这是不正确的，void实际代表不确定的，void类型也就是还未明确的类型，以malloc函数为例，函数定义如下：

```c
#include <stdlib.h>
void *malloc(size_t size);
```

我们在给一个指针变量p分配一个size大小的空间时，并不知道这个指针变量是什么类型，可能是int型指针，也可能是char型指针，所以函数定义的时候用了void类型，等使用的时候再根据实际情况强制转换成对应的类型，如下给int型指针变量分配4字节内存：

```c
int *p = NULL;
p = (int *)malloc(sizeof(int));
```

所以，void类型都是事先并不确定类型，最终归宿也是被强制转换成其他类型。

## 3. main函数之传参

与第一种情况不同，main函数传参可根据传参的内容，不需要重新编译程序，就能控制main函数执行的结果。

### 3.1 argc和argv

argc的类型是int型，说明argc是一个int型变量，表示程序运行时给main函数传递了几个参数；argv的类型是char *型，说明argv是一个char *型的字符串数组，这个数组中存放着多个字符串，每个字符串都是给main函数传参的实际内容，数组个数就是argc，argv[0]是给main函数传递的第一个参数，argv[1]是给main函数传递的第二个参数，以此类推。我们来看个例子，在test.c的文件内输入如下内容：

```c
#include<stdio.h>
int main(int argc, char *argv[])
{
    int i;
    printf("argc的个数是%d\n",argc);
    for(i=0;i<argc;++i)
    {
        printf("第%d个数的传参是%s\n",argc,argv[i]);
    }
    return 0;
}
```

编译后输入`./a.out`得到如下结果：

```c
argc的个数是1
第1个数的传参是./a.out
```

总结：在没有对main函数传递参数的时候，程序执行反馈的结果仍然有一个传参，传参的内容就是我们输入的`./a.out`命令。

输入`./a.out 123   345`得到结果：

```c
argc的个数是3
第3个数的传参是./a.out
第3个数的传参是123
第3个数的传参是345
```

总结：main函数实际传递的参数是从第二个开始计数，传递的参数内容就是在./a.out命令后面输入的内容，传递的参数用空格来间隔，多个间隔也仅会当一个空格来处理。

### 3.2 传参说明

通过一个简单的例子来说明main函数如何通过传参来控制程序输出：

```c
#include<stdio.h>
#include<string.h>
int main(int argc, char *[])
{
    if(argc != 2)
    {
        printf("we need to two param.\n");
        return -1;
    }
    if(!strcmp(argv[1],"0"))
    {
        printf("girl.\n");
    }
    else if(!strcmp(argv[1],"1"))
    {
        printf("boy.\n");
    }
    else
        printf("Unknowd.\n");
    return 0;
}
```

输入`./a.out 0`或者`./a.out 1`来控制程序执行的输出。

```c
porter@ubuntu:~/windows_share$ ./a.out 0
girl.
porter@ubuntu:~/windows_share$ ./a.out 1
boy.
```

这边需要注意的是：main函数传参时一定要检验argc，否则容易造成argv字符串数组溢出出现段错误。

## 4. 扩展之NULL

当我们在定义一个指针的时候，经常用NULL来给指针赋初值，同时在应用指针的时候也会用NULL来进行指针内容的判断，那NULL究竟是什么？下面一起来探讨下。

### 4.1 NULL定义

NULL不是C语言的关键字，它是一个宏，定义如下：在C++中NULL等同于0，在C语言中NULL表示void *类型的0，其实本质还是0。

```c
#ifdef _cplusplus
#define NULL 0
#else
#define NULL (void *)0
#endif
```

### 4.2 NULL使用

如上面介绍，NULL的使用惯例是为指针赋初值，代表着指针指向0x0000，通常在内存的区域划分中，以0x0000为基地址的区域是一个受保护的区域，一般程序无法访问去篡改其中的数值，所以将这个基地址赋值给新定义的指针，可以保证这个指针不会胡乱指向别的空间篡改了数值造成程序错误，如果不给指针赋初值，那这个定义的指针就叫做`野指针`，野指针可以指向内存任意地址空间，在程序运行中会造成无法预料的问题：

```c
int *p = NULL;                      //定义int型指针p，并赋值NULL
p = (int *)malloc(sizeof(int)*5);   //为指针p分配20字节空间
if(NULL == p)                       //判断p是否为0
```

注意上面用NULL来判断p是否为0的时候，写成`NULL == p`而不是`p == null`，这是为了防止我们疏忽将判断等式写成了赋值表达式`p = NULL`，程序在编译过程中是不会报错出警告的，这就加重了调试的困难度。

### 4.3 NULL比较

既然NULL表示0，为了同其他字符以示区分，这边来对如下字符进行比较：

```c
'\0'：是一个转义字符，对应ASCII码的值是0(十进制)，本质是0；
'0'：是一个字符，对应ASCII码的值是48(十进制)，本质是48；
0：是一个数字0，本质就是0；
NULL：是一个表示式，是强制类型转换为void *类型的0，本质也是0。
```

总结： 
- '\0'用法是C语言字符串的结尾标志，一般放在字符串最后，用来判断字符串是否已经结束；
- '0'是字符0，一般用来获取0对应的ASCII码值；
- 0是数字0，用来判断int类型的变量是否为0；
- NULL是一个表达式，一般用来比较指针是否为野指针。

## 5. 扩展之类型转换

程序中经常使用强制类型转换将不同类型的变量转换成我们需要的类型变量，那类型转换在内存中如何体现呢？通过下面的例子来看下：

```c
#include<stdio.h>
int main(void)
{
    float a = 12.34;
    int b = (int)a;
    printf("b = %d\n",b);
    printf("a = %f\n",a);
    return 0;
}
```

程序执行结果：b = 12, a = 12.34

很简单的示例，通过将float型变量a强制转换成int型后赋值给变量b，思考下程序已经对a做了强制转换，为什么打印出来a的值还是12.34呢？再来看一个例子：

```c
#include<stdio.h>
int main(void)
{
    int a = 10;
    int b = 3;
    float d = 0;
    d = (float)a/b;
    printf("d = %f\n",d);
    return 0;
}
```

程序执行结果：d = 3.0000

结果为什么是3.0000而不是3.3333呢？

![](image/类型转换.svg)

如图介绍，在内存中类型转换并不是一步完成的，而是分成了4步来完成：

- 第一步：在栈区创建一个临时变量x，类型与d的类型一致，也是float型；
- 第二步：因为a和b的类型都是int型，所以a/b的结果也是int型取整为数值3，将3赋值给临时变量x；
- 第三步：将临时变量x的值赋给变量d，因为是float型，所以要取四位小数，所以d的值为3.0000；
- 第四步：在栈区销毁临时变量x。

总结：当对一个变量或表达式进行强制类型转换，内存中会创建一个临时变量来存储计算后的数值，并将这个数值赋给对应的变量，而内存中实际存储的值并没有进行改动，程序执行完会自动销毁这个临时变量。