## 1. static介绍

&emsp;&emsp;static是C语言的一个关键字，通常一个关键字只有一个含义，也就是一种用法，但static不同，它具有两种含义，且这两种含义相互之间没有任何关联。

- static修饰局部变量
- static修饰全局变量或函数

&emsp;&emsp;在介绍static功能之前，先来了解下内存的管理方法，大致可以划分为栈、堆、数据段、bss段、代码段这五部分。

### 1.1 栈(stack)

&emsp;&emsp;栈其实是一种数据结构，是系统管理内存的一种方式，C语言将局部变量(auto修改的变量，通常auto会省略，仅在语句块中使用)存储在栈上。

&emsp;&emsp;以下面例子来说明：假设栈空间大小为32K，栈空间为空时，Top指针和Bottom指针都指向地址0x0000，此时定义一个int型的局部变量a并赋值为4，因为int型变量占4个字节，则数值4就被存储在地址为0x0000 ~ 0x0003所代表的空间中，而Top指针向上移动指向0x0004；同理，再定义一个double型变量b并赋值为8.0000，则地址0x0004 ~ 0x000b所代表的空间存储着变量b的数值8.0000，Top指针继续向上移动到0x000c；在为变量a和变量b分配空间的时候，Top指针会随着空间的分配而移动，Bottom指针一直指向原始地址不变。

&emsp;&emsp;同样的，当释放double型局部变量b时，Top指针向下移动到地址0x0004，数值8.0000存储的空间就被系统释放，此时要记住，原先空间中存储变量b的数值并没有被清空（这就是下面要讲到的脏内存）；最后如果语句块代码执行结束，变量a的空间也会被释放，Top指针最终仍然指向原始地址0x0000。值得注意的是，在此过程中，要想释放变量a的空间就必须先释放变量b的空间，无法跳过变量b先释放变量a，这就像一个储物柜，先放进去的东西只能等到最后才能拿出来，这就是栈很重要的一个特点叫先进后出(FILO)，也可称为后进先出(LIFO)。

![](./image/stack.svg)

从上面流程分析中可以总结如下几点：

- **栈对于局部变量的空间分配是系统来分配的**：当程序员定义一个局部变量时，系统就会为这个变量自动分配一个空间；同理释放栈空间也是由系统自动回收的，无需程序员操作；
- **栈空间是被重复使用的**：栈空间由系统分配释放，所以随着语句块程序的执行和结束，栈空间会不停分配和释放，所以栈空间在代码执行过程中会被重复使用，实际的分配地址空间也是根据Top指针来随机分配的；
- **栈空间是脏内存**：由于栈空间的重复使用，原先空间中存放的数值并没有随着空间的释放而被清理，所以当我们定义一个局部变量时一定要对变量进行初始化，否则变量的值会因为脏内存而产生随机的值，不确定的值会增加程序的风险性；
- **栈空间大小是固定的**：不同于堆空间，栈空间大小是固定的，且容量一般较小，所以在定义布局变量时一般不建议占用较大的空间，容易引发段错误或造成数组溢出；
- **语句块不可返回局部变量或不可作用域外访问局部变量**：局部变量有其自身的作用域，当语句块代码执行结束超出局部变量作用域时，栈空间就被释放，此时从变量作用域外去访问此变量是有风险的，同时当语句块代码执行结束也不可返回此局部变量，因为存放该变量的地址空间已经被释放。

### 1.2 堆(heep)

&emsp;&emsp;系统内存的容量随着发展越来越大，管理也越来越复杂，因为系统内众多进程并行处理随时都可能申请或释放内存，而且申请的内存空间大小不定。在此之下就引出了堆，堆同栈一样，也是系统实现内存管理的一种方式，但与栈的差异较大。

通过下面例子进行说明：

```c
int *p = NULL;
p = (int *)malloc(sizeof(int)*25);
if(NULL == P)
    printf("heep memory application failed!\n");
else
    ...
free(p);
p = NULL;
```

示例中，我们定义了一个int型指针p，并赋值为NULL，同时在后面加了内存是否分配成功的判断(关于`NULL`的说明可参考[Main函数的思考](main.md)第4节)；堆内存的分配是用`malloc`函数来分配的，分配的内存大小是可以自己定义的，当前为变量p分配了100字节，另外除了malloc可以分配堆空间之外，还有另外同类函数也可以实现堆内存的分配：

```c
#include <stdlib.h>                        //使用堆内存分配函数必须包含的头文件
void *malloc(size_t size);                 //为指针变量ptr分配size大小的堆内存，这边void *类型会在内存分配中强制转换成相对应的类型
void *calloc(size_t nmemb, size_t size);   //为指针变量ptr分配nmemb个内存，每个内存大小为size，calloc函数与malloc的区别在于，calloc可以分配多个内存，总内存大小为nmemb*size
void *realloc(void *ptr, size_t size);     //为已分配的指针变量ptr重新分配size大小的内存，如果ptr是NULL，其功能相当于malloc
void free(void *ptr);                      //释放之前为指针变量ptr分配的内存
```

通过上面的例子及阐述，可以总结如下几点：

- **堆内存由malloc、calloc和realloc来分配**：堆内存只能用来储存由malloc、calloc和realloc函数分配的变量，其他变量不会存储到堆中；
- **堆内存分配后要对变量进行判断**：malloc等函数成功分配则返回指向这块内存的首地址，若分配失败则返回空指针NULL，所以在程序使用前一定要进行判断；
- **堆空间使用结束一定要释放内存**：堆内存空间较大，但也是有上限的，程序执行中会反复进行内存申请，如果不释放内存，已申请到的内存会被一直占用着，最终导致内存空间不足出现错误；
- **堆内存分配之前和释放之后为指针变量赋值NULL**：目的是避免野指针的出现，野指针表示可以指向任意地址的指针，此指针地址是不确定的，如果指针指向不可访问区域会引发段错误，如果指向其他地址空间，对指针赋值后会修改原先储存的值造成其他不可控的问题；
- **堆内存未释放之前勿堆内存首地址进行赋值**：目的为防止内存泄漏，也叫做内存丢失，这个丢失就是无法访问这块内存，因为指针被重新赋值后，原先的地址就被覆盖了，新的地址是指向另外的空间，原先的内存就丢失了，free函数也无法对内存进行回收；
- **堆内存分配的最小字节为24bytes(基于64位)**：通过如下示例说明

```c
//程序
#include<stdio.h>
#include<stdlib.h>
#include<malloc.h>
int main(void)
{
    int *p = NULL;
    int byte = 0,n = 0;
    printf("please input a unsigened number:");
    while(scanf("%d",&n)!='\0')
    {
        p = (void *)malloc(sizeof(int)*n);
        if(NULL == p)
            printf("malloc failed!\n");
        byte = malloc_usable_size(p);
        printf("byte's size is %d\n",byte);
    }
    free(p);
    p = NULL;
    return 0;
}

//结果
please input a unsigened number:6
byte's size is 24
3
byte's size is 24
2
byte's size is 24
7
byte's size is 40
10
byte's size is 40
50
byte's size is 200
15
byte's size is 72
```

总结：当对n输入0 ~ 6即申请的内存小于等于24bytes时,实际得到的内存都为24bytes，但当n的输入值大于6时，实际得到的内存会大于等于我们向堆申请的内存。也就是说malloc等函数向堆申请内存时，堆内存最低分配的字节时24bytes(32位为16bytes)，当申请的内存大于24bytes时，因为C语言的内存对齐，实际得到的内存会大于等于我们需求的内存。

另外在函数中，可以通过`malloc_usable_size`函数将堆实际分配的内存打印出来，如果ptr指向分配内存的首地址即malloc分配内存成功则函数返回实际得到的内存大小，如果ptr是空指针则返回0，函数定义如下：

```c
#include <malloc.h>
size_t malloc_usable_size (void *ptr);
```

### 1.3 数据段

### 1.4 bss段

### 1.5 代码段

## 2. static修饰局部变量

## 3. static修饰全局变量或函数